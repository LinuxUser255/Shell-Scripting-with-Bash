
# Globbing cheatsheet

WIP

## Basic globbing

| **Character** | **Description** | 
| --- | --- | 
| `*` | Matches any character zero or more times, except for `/` | 
| `**` | Matches any character zero or more times, including `/` | 
| `?` | Matches any character except for `/` one time | 
| `[abc]` | Matches any characters inside the brackets. For example, `[abc]` would match the characters `a`, `b` or `c`, and nothing else. | 

Notes:

- `*` typically does not match dotfiles (file names starting with a `.`) unless explicitly enabled by the user [via options](#common-options) 
- `?` also typically does not match the leading dot
- More than two stars in a glob path segment are typically interpreted as _a single star_ (e.g. `/***/` is the same as `/*/`)

## Extended globbing

### brace expansion

TODO

### extglob

| **pattern** | **regex equivalent** | **description** | 
| --- | --- | --- | 
| `?(pattern-list)` | `(...|...)?` | Matches zero or one occurrence of the given patterns | 
| `*(pattern-list)` | `(...|...)*` | Matches zero or more occurrences of the given patterns | 
| `+(pattern-list)` | `(...|...)+` | Matches one or more occurrences of the given patterns | 
| `@(pattern-list)` | `(...|...)` <sup>*</sup> | Matches one of the given patterns | 
| `!(pattern-list)` | N/A | Matches anything except one of the given patterns | 

### POSIX character classes 

TODO

## Globbing options

Options that are commonly available on various globbing implementations.

| **Option name** | **Description** | 
| --- | --- | 
| `extglob` | Enable extended globs. In addition to the traditional globs (using wildcards: `*`, `*`, `?` and `[...]`), extended globs add (almost) the expressive power of regular expressions, allowing the use of patterns like `foo/!(a|b)*` | 
| `dotglob` | Allows files beginning with `.` to be included in matches. This option is automatically enabled if the glob pattern begins with a dot. Aliases: `dot` (supported by: [minimatch][], [micromatch][]) | 
| `failglob` | report an error when no matches are found | 
| `globignore` allows you to specify patterns a glob should not match  Aliases: `ignore` (supported by: [minimatch][], [micromatch][]) | 
| `globstar` | recursively match directory paths (enabled by default in [minimatch][] and [micromatch][], but not in [bash][]) | 
| `nocaseglob` | perform case-insensitive pathname expansion | 
| `nocasematch` | perform case-insensitive matching. Aliases: `nocase` (supported by: [minimatch][], [micromatch][]) | 
| `nullglob` | when enabled, the pattern itself will be returned when no matches are found. Aliases: `nonull` (supported by: [minimatch][], [micromatch][])



#ASTERIX(*)
The asterisk * is interpreted by the shell as a sign to generate filenames,
matching the asterisk to any combination of characters (even none). 
When no path is given, the shell will use filenames in the current directory.

#QUESTION MARK (?)
Similar to the asterisk, the question mark ?, is interpreted by the shell 
as a sign to generate filenames, matching the question mark with exactly one character.


# SQUARE BRACKETS ( [] )
The square bracket [ is interpreted by the shell as a sign to generate 
ilenames, matching any of the characters between [ and the first subsequent ].
The order in this list between the brackets is not important. 
Each pair of brackets is replaced by exactly one character.
You can also exclude characters from a list between square brackets with the exclamation mark !. 
And you are allowed to make combinations of these wild cards


a-z and 0-9 ranges  & A-Z for CAPS
The bash shell will also understand ranges of characters between brackets.

$LANG and square brackets
But, don't forget the influence of the LANG variable. Some languages include lower case letters in an upper case range (and vice versa).

-------------------------------------------------------------------------------------------------------------------------------------


#* 0 or more chars could be begin or end of the word

#*a* anything wit a in it

#[] is OR betweeen a range of characters 

#[ab]*

#? must be 1 or more chars at the start 

#?*a     one char infront. then followed by zero or more (a)
#        must be at least one char infront of the A

#?l*a    must be once character then possibly an l followed by any number of            

#!    ls [!ad]* negate the a or b

#ls *[[:upper:]]*    search for just upper
#ls *[[:digit:]]*    search for just digits
#ls *[[:punct:]]*    search for chars with punctuation

#======================================================================


# ls
# ls *
# ls *a*..............................anthing with an a in it
# ls [ab]* ...........................range a through b
# ls ?*a
# ls ?l*a
# ls [!ab]*
# ls *[[:upper:]]*
# ls *[[:digit:]]*
# ls *[[:punct:]]*

